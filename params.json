{"name":"Goquic","tagline":"QUIC support for Go","body":"goquic, QUIC support for Go\r\n===========================\r\n\r\nThis is a work-in-progress QUIC implementation for Go. This is based on\r\n[libquic](https://github.com/devsisters/libquic) library, which is in turn based\r\non original QUIC implementation on [Chromium](http://www.chromium.org/quic).\r\n\r\nQUIC is an experimental protocol aimed at reducing web latency over that of TCP.\r\nOn the surface, QUIC is very similar to TCP+TLS+SPDY implemented on UDP. Because\r\nTCP is implement in operating system kernels, and middlebox firmware, making\r\nsignificant changes to TCP is next to impossible. However, since QUIC is built\r\non top of UDP, it suffers from no such limitations.\r\n\r\nKey features of QUIC over existing TCP+TLS+SPDY include\r\n\r\n  * Dramatically reduced connection establishment time\r\n  * Improved congestion control\r\n  * Multiplexing without head of line blocking\r\n  * Forward error correction\r\n  * Connection migration\r\n\r\n## Project Status\r\n\r\n*This library is highly experimental.* Although `libquic` sources are from\r\nChromium (which are tested), the Go bindings are still highly pre-alpha state.\r\n\r\nKnown issues:\r\n\r\n  * No support for read streaming. All request must fit in memory.\r\n  * Secure QUIC not fully tested. May not support ECDSA certificates.\r\n\r\nThings to do:\r\n\r\n  * Read streaming support\r\n\r\n## Preliminary Benchmarks\r\n\r\nA very primitive benchmark testing have been done. Testing environments below:\r\n\r\n| Items        | Description                                               |\r\n| ------------ | --------------------------------------------------------- |\r\n| Optimization | libquic built with `-O3` parameters                       |\r\n| CPU          | Intel(R) Core(TM) i7-4930K CPU @ 3.40GHz                  |\r\n| Server Code  | https://github.com/devsisters/goquic/blob/master/example/server.go |\r\n| Server Parms | `GOMAXPROCS=12 ./server -port 9090 -n 12`                 |\r\n| Client Code  | https://github.com/devsisters/quicbench/blob/master/quicbench.go |\r\n| Client Parms | `./quicbench -u=\"https://example.com:9090/\" -c 200 -r 1000` |\r\n\r\nThe server code is modified to create 30B, 1kB, 5kB, 10kB HTTP body payload.\r\nConcurrency is 200 and each thread requests 1,000 requests. It is designed to\r\nmeasure ideal throughput of the server. Naturally the throughput goes down when\r\nconcurrency increases.\r\n\r\nBenchmark results:\r\n\r\n| Payload Size | Requests per Second |\r\n| ------------ | ------------------- |\r\n| 30B Payload  | 23832.18 RPS        |\r\n| 1kB Payload  | 21704.84 RPS        |\r\n| 5kB Payload  | 9343.58 RPS         |\r\n| 10kB Payload | 5312.75 RPS         |\r\n\r\nOn 10kB case, calculating the total network throughput is `435Mbps`.\r\n\r\nHow many connections per second can this server process?\r\n\r\n`./gobench -u=\"https://example.com:9090/\" -c 200 -r 100 -qk=false`\r\n\r\nTurning off keepalive using `qk` option results in a pure new QUIC connection\r\nper request. The benchmark results are `2905.58 CPS`.\r\n\r\n\r\nGetting Started\r\n===============\r\n\r\n## Build static library files\r\n\r\nAlthough prebuilt static library files already exists in the repository for\r\nconvenience, it is always good practice to build library files from source. You\r\nshould not trust any unverifiable third-party binaries.\r\n\r\nTo build the library files for your architecture and OS:\r\n\r\n```bash\r\n./build_libs.sh\r\n```\r\n\r\nThis will fetch `libquic` master and build all the binaries from source. The\r\nC/C++ files for Go bindings will be all built too.\r\n\r\nCurrently Linux and Mac OS X is supprted.\r\n\r\n## How to build\r\n\r\nDue to Go 1.4's cgo restrictions, use an environment variable like below to\r\nbuild your projects. This restriction will be removed from Go 1.5.\r\n\r\n```bash\r\nCGO_CFLAGS=\"-I$GOPATH/src/github.com/devsisters/goquic/libquic/boringssl/include\" \\\r\nCGO_LDFLAGS=\"-L$GOPATH/src/github.com/devsisters/goquic/lib/$GOOS_$GOARCH\"\r\n```\r\n\r\nFor example, building goquic example server in Mac:\r\n\r\n```bash\r\nCGO_CFLAGS=\"-I$GOPATH/src/github.com/devsisters/goquic/libquic/boringssl/include\" \\\r\nCGO_LDFLAGS=\"-L$GOPATH/src/github.com/devsisters/goquic/lib/darwin_amd64\" \\\r\ngo build $GOPATH/src/github.com/devsisters/goquic/example/server.go\r\n```\r\n\r\nSPDY/QUIC support\r\n=================\r\n\r\nWe have a experimental SPDY/QUIC implementation as a library.\r\nYou can use this library to add SPDY/QUIC support for your existing Go HTTP server.\r\n\r\nSee our SPDY-QUIC server/client implementation [here](example/).\r\n\r\n## How to use server\r\n\r\nWhen running a HTTP server, do:\r\n\r\n```go\r\ngoquic.ListenAndServe(\":8080\", 1, nil)\r\n```\r\n\r\ninstead of\r\n\r\n```go\r\nhttp.ListenAndServe(\":8080\", nil)\r\n```\r\n\r\n## How to use client\r\n\r\nYou need to create http.Client with Transport changed, do:\r\n\r\n```go\r\nclient := &http.Client{\r\n\tTransport: goquic.NewRoundTripper(false),\r\n}\r\nresp, err := client.Get(\"http://example.com/\")\r\n```\r\n\r\ninstead of\r\n\r\n```go\r\nresp, err := http.Get(\"http://example.com/\")\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}