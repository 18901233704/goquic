{"name":"GoQuic","tagline":"QUIC support for Go","body":"Introducing GoQuic - A quick way to use QUIC\r\n=====================================\r\n\r\nMobile Internet connection is getting faster each day. We've transitioned from a very slow GSM network to 3G and then to a fastest LTE networks. Despite the connection speed getting faster each day, we constantly struggle to stably load web pages. Trying to browse while moving in a subway, Internet browsing is constantly interrupted by the signal blackouts to the point where it's so unbearable that we just stop doing it. It's not a throughput problem. It's about the stability of the connection. The problem is about dealing with highly variable network environment.\r\n\r\nFortunately, we can solve this problem right now: with \"QUIC\". Let's see how it compares.\r\n\r\n    TODO: HTTP/1+TLS vs HTTP/2+TLS vs QUIC 데모 gif\r\n\r\n### Difficulty of Mobile Internet\r\n\r\nAt Devsisters server team, we constantly research ways to improve our mobile game user's online experience. More and more, mobile games are becoming sophisticated. And many of the games released today require internet to play. But unlike the PC game counterparts, mobile environment poses some difficult challenges while creating online mobile games.\r\n\r\nMobile phones are literally - \"mobile\". So their online connectivity changes along with the mobile phone's physical location change. Constant transition from this wifi to that wifi, transitioning to and from cellular data, occasional cellular signal blackouts all make mobile internet connection very unstable and unreliable.\r\n\r\nThis kind of environment pose serious user experience problems. Everybody with a smartphone would agree on how frustrating it is when the wifi signal weakens enough to transition to a cellular data network. It literally makes web browsing unbearable for a few seconds.\r\n\r\nWhen wifi signal is lost during a web browsing session, wifi is disconnected and transits to other available wifi or cellular data network. And sometimes during that period, currently loading web page takes ages to finish. But instead of waiting, pressing the refresh button often makes the page load faster. Users with a keen observation would have experienced this phenomena.\r\n\r\nThis kind of problem happens because of the way TCP handles packet loss. TCP views packet loss as a network congestion signal. So under the condition of \"network blackout\" it slows down sending packets exponentially to the point until no more packets are sent. So when this kind of event triggers, even if the underlying network recovers, TCP connection requires more time to recover it's connectivity. So in this situation -- from the user's perspective, it is more wise to simply press refresh button instead of waiting for the loading to finish.\r\n\r\n![TCP Connection Recovery After Network Blackout](http://d2.naver.com/content/images/2015/06/helloworld-111111-13.png)\r\n\r\nThere are only two ways to handle this problem on HTTP. Waiting indefinitely or timeout and retry. This kind of problem also exists on HTTP/2 which it also use TCP. It's also worse on HTTP/2 since it uses connection multiplexing network blackouts stop all logical HTTP requests, causing significant performance degradation. This kind of problem is called head-of-line blocking.\r\n\r\nHead-of-line blocking is not the only problem in HTTP. Since more and more services use HTTPS, it is becoming more expensive to initialize a connection. So it directly impacts 'timeout and retry' strategy. In the mobile environment, where cellular latency of a 3G connection is in 200~300ms range, the [3 round-trip HTTPS connection][1] handshake is too expensive.\r\n\r\n### Google's Experiment: QUIC\r\n\r\nFortunately, Google is trying to solve this problem by developing and researching a new protocol named QUIC. Since the problem is happening because of HTTP/TLS and TCP, we can't fix it on the TCP layer. So QUIC is directly developed upon UDP transport layer.\r\n\r\nQUIC aims to solve the head-of-line blocking issue and the TLS connection round-trip problem. Detailed project description is available in the [QUIC project page][2].\r\n\r\nUnfortunately, since QUIC is a experimental protocol, there's only one implementation of the protocol. And that implementation exists in project Chromium. Google provides toy server/client to play with. But the source code itself is no designed to be a library. It is heavily coupled to the existing Chromium sources.\r\n\r\n### Birth of libquic and goquic\r\n\r\nOur initial plan was to incorporate Chromium's network runtime into our game client and server. But it turned out to be horribly hard. We then tried to extract minimal amounts of source code from Chromium to barely run QUIC code. That made the birth of project [libquic][3]: which is a bare essential standalone source code extracted from Chromium. It can build on Mac and Linux platforms and produce libquic library.\r\n\r\nOur next step was to create a Golang binding. Since our server stack is developed in Go, it was a natural choice. This led to birth of [goquic][4]. It tries to mimic the builtin HTTP library and also incorporates [bradfitz' http2 library][5] to enable HTTP/2 when QUIC is unavailable.\r\n\r\n### Performance of goquic\r\n\r\nA very primitive benchmark testing have been done. Testing environments below:\r\n\r\n| Items        | Description                                               |\r\n| ------------ | --------------------------------------------------------- |\r\n| Optimization | libquic built with `-O3` parameters                       |\r\n| CPU          | Intel(R) Core(TM) i7-4930K CPU @ 3.40GHz                  |\r\n| Server Code  | https://github.com/devsisters/goquic/blob/master/example/server.go |\r\n| Server Parms | `GOMAXPROCS=12 ./server -port 9090 -n 12`                 |\r\n| Client Code  | https://github.com/devsisters/quicbench/blob/master/quicbench.go |\r\n| Client Parms | `./quicbench -u=\"https://example.com:9090/\" -c 200 -r 1000` |\r\n\r\nThe server code is modified to create 30B, 1kB, 5kB, 10kB HTTP body payload.\r\nConcurrency is 200 and each thread requests 1,000 requests. It is designed to\r\nmeasure ideal throughput of the server. Naturally the throughput goes down when\r\nconcurrency increases.\r\n\r\nBenchmark results:\r\n\r\n| Payload Size | Requests per Second |\r\n| ------------ | ------------------- |\r\n| 30B Payload  | 23832.18 RPS        |\r\n| 1kB Payload  | 21704.84 RPS        |\r\n| 5kB Payload  | 9343.58 RPS         |\r\n| 10kB Payload | 5312.75 RPS         |\r\n\r\nOn 10kB case, calculating the total network throughput is `435Mbps`.\r\n\r\nHow many connections per second can this server process?\r\n\r\n`./gobench -u=\"https://example.com:9090/\" -c 200 -r 100 -qk=false`\r\n\r\nTurning off keepalive using `qk` option results in a pure new QUIC connection\r\nper request. The benchmark results are `2905.58 CPS`.\r\n\r\n### QUIC Proxy Server Docker Image\r\n\r\nI used to create a QUIC reverse proxy of an existing site just for fun. So to enable people to experiment with QUIC, we've released a docker image that acts as a reverse proxy for the site of your choice. It enables QUIC along with HTTP/2, so you will enjoy full bleeding edge of web browsing.\r\n\r\n    TODO: Instructions on how to use docker image\r\n\r\nHave fun! :)\r\n\r\n[1]: http://www.semicomplete.com/blog/geekery/ssl-latency.html\r\n[2]: http://www.chromium.org/quic\r\n[3]: https://github.com/devsisters/libquic\r\n[4]: https://github.com/devsisters/goquic\r\n[5]: https://github.com/bradfitz/http2","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}